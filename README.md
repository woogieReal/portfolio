<table style="border: none; width: 100%; margin-bottom: 24px;">
<tr style="border: none;">
<td style="border: none; width: 110px; vertical-align: top;">
<img src="./images/profile.jpg" alt="profile" width="100" style="border-radius: 12px; border: 1px solid #ccc;" />
</td>
<td style="border: none; vertical-align: middle; padding-left: 12px;">
<div style="font-size: 28px; font-weight: 700; margin-bottom: 4px;">
김재욱 ✨
</div>
<div style="font-size: 16px; color: #666;">
Backend · AI Engineer
</div>
</td>
</tr>
</table>

## **AI 기반 백엔드·인프라 설계에 강점을 가진 엔지니어입니다 ⚙️**
실제 서비스 환경에서 OpenSearch·Bedrock 기반 **의미 검색 · 입력자동화 · RAG 시스템**을 구축하며 데이터 구조·검색 품질·프롬프트 최적화 등 **AI 기능을 실무 수준에서 안정화**한 경험을 가지고 있습니다.

AWS 기반 인프라 운영 역량과 함께, 다양한 서비스 개발 과정에서 **68개 이상 DB 테이블·스키마 구조를 설계**하고 **200개 이상의 API 엔드포인트(총 207개 이상)를 직접 개발·운영**하며 복잡한 시스템 요구사항을 구조적으로 해결해 왔습니다. 이를 통해 데이터 흐름·모델링·도메인 설계에 대한 실전 감각을 쌓았고, 대규모 기능을 안정적으로 이어 붙이는 아키텍처 역량을 갖추었습니다.

또한 성능 개선(최대 **40% 단축**), 중복 문제 제거, 인프라 안정화 등을 통해 실제 운영 효율을 높이는 결과를 일관되게 만들어 왔습니다.

<br>

## **팀과 함께 성장하는 개발자입니다 🤝**
- 기술적 판단의 근거를 명확하게 공유하고
- 설계/아키텍처/문제 해결 경험을 문서화하며
- 팀 전체의 속도를 높이는 구조를 만드는 것을 중요하게 생각합니다

<br>

## About

<table style="width:100%;border:none">
<tr style="border:none;">
<td style="border:none;vertical-align:top;width:50%;">
<p style="margin:4px 0;"><span style="font-size:16px;">📅</span>&nbsp;1994년생 (만 31세)</p>
<p style="margin:4px 0;"><span style="font-size:16px;">📧</span>&nbsp;woogiereal@gmail.com</p>
<p style="margin:4px 0;"><span style="font-size:16px;">📱</span>&nbsp;010-7232-5609</p>
</td>
<td style="border:none;vertical-align:top;width:50%;">
<p style="margin:4px 0;"><span style="font-size:16px;">💼</span>&nbsp;<a href="https://github.com/woogieReal">GitHub</a></p>
<p style="margin:4px 0;"><span style="font-size:16px;">📄</span>&nbsp;정보처리기사 / JLPT N1 / TOEIC 890</p>
<p style="margin:4px 0;"><span style="font-size:16px;">📍</span>&nbsp;5년차 백엔드 개발자</p>
</td>
</tr>
</table>

<br>

## Skills

<table style="width:100%;border:none">

<tr style="border:none;">
<td style="border:none;vertical-align:top;width:50%;">
<h3 style="margin:4px 0;">🖥 Backend</h3>
<ul style="margin:4px 0;padding-left:16px;">
<li style="margin:2px 0;">Python · Node.js · Java</li>
<li style="margin:2px 0;">Flask · FastAPI · InversifyJS</li>
</ul>
</td>

<td style="border:none;vertical-align:top;width:50%;">
<h3 style="margin:4px 0;">☁ Infra / Cloud</h3>
<ul style="margin:4px 0;padding-left:16px;">
<li style="margin:2px 0;">AWS Lambda · API Gateway · S3 · OpenSearch · Bedrock</li>
<li style="margin:2px 0;">CloudFormation · IAM · VPC/Subnet · Security Group · EventBridge</li>
</ul>
</td>
</tr>

<tr style="border:none;">
<td style="border:none;vertical-align:top;width:50%;">
<h3 style="margin:4px 0;">🔧 DevOps</h3>
<ul style="margin:4px 0;padding-left:16px;">
<li style="margin:2px 0;">Docker · GitHub Actions · Jenkins (CI/CD)</li>
<li style="margin:2px 0;">CloudWatch Logs · EventBridge</li>
</ul>
</td>

<td style="border:none;vertical-align:top;width:50%;">
<h3 style="margin:4px 0;">💾 Database</h3>
<ul style="margin:4px 0;padding-left:16px;">
<li style="margin:2px 0;">MySQL · Redis · DynamoDB</li>
<li style="margin:2px 0;">Stored Procedure · Trigger · Event Scheduler · SQL 성능 최적화</li>
</ul>
</td>
</tr>

</table>

<br><br>

# 1. 고객 불편사항 관리 시스템 AI 서비스 신규 개발 (2025.05 ~ 2025.09)
## 1.1. 개요
- **프로젝트 유형:** 고객 불편사항 관리 시스템의 **AI 서비스 신규 기능** 개발
- **참여 인원:** 4명
  - 백엔드 겸 프론트엔드 2명
  - 기획 겸 퍼블리싱 1명
  - PM 1명
- **담당 역할:**
  - **AI 신규 기능 전체 백엔드 설계·구현 담당**
  - **AWS 인프라 리소스 설계 및 생성**
  - 기능 단위 **작업 일정 수립 및 인프라 구성 계획**
- **기술 스택:**
  - **인프라:** AWS(**OpenSearch**, **Bedrock**, Lambda, EventBridge, CloudFormation, CloudWatch, DynamoDB, Aurora MySQL, SSM Parameter Store, IAM)
  - **백엔드:** TypeScript, InversifyJS, AWS SDK
  - **프론트엔드:** React, TypeScript

<br>

## 1.2. 프로젝트 설명
본 프로젝트는 다수의 고객 불편사항을 관리하는 시스템에 AI 기능을 신규 도입한 사례로, **① 유사사례 검색**과 **② 입력자동화** 기능 개발을 중심으로 진행되었다.

### ① 유사사례 검색
- 서비스 운영 중 누적된 불편사항 데이터에서 **의미적으로 유사한 사례를 효율적으로 탐색하기 위해** 설계하였다.
- 기존 키워드 기반 검색의 한계를 보완하기 위해 **Amazon OpenSearch**를 활용한 **텍스트 임베딩 기반 의미 유사도 검색 기능**을 구축하였다.
- 또한, 유사사례의 개선 요청 내용을 LLM과 결합하여 **자동 개선 요청문 생성 기능**을 구현하였다.

### ② 입력자동화
- 불편사항 등록 시 **선택해야 하는 항목이 많아 작성 과정이 복잡했던 문제**를 해결하기 위해 개발되었다.
- 고객의 불편사항과 함께 코드값 및 입력 가이드를 **LLM**에 전달하여, **모델이 적절한 입력 항목을 자동으로 완성**하도록 설계하였다.

<br>

## 1.3. 담당 업무
- **유사사례 검색 기능 구현:**
  - Amazon OpenSearch의 **벡터 검색 기능**을 활용하여 기존 데이터와 신규 입력 데이터를 비교
  - **유사도 기반으로** 기존 불편사항을 자동 조회하고 중복 등록을 방지하는 기능 개발

- **자동 개선 요청문 생성:**
  - **Bedrock LLM**(Claude 계열 모델)을 이용해 담당자가 입력한 불편사항과
    유사사례의 개선 요청 내용을 함께 활용하여 **자동 개선 요청문**을 생성하는 기능 개발

- **입력 항목 자동 추천:**
  - 고객 불편사항 입력 시 필요한 코드값 정보와 관리자가 작성한 입력 가이드를 함께 **LLM에 전달**
  - 모델이 적절한 입력 항목을 **자동으로 선택하고 작성**하도록 기능을 개발

<br>

## 1.4. 기술적 특징

<div style="display: flex; gap: 16px;">
<img src="./images/RDS 데이터 OpenSearch 인덱싱.png" style="width: 55%" />
<img src="./images/OpenSearch 기반 유사사례 조회.png" style="width: 45%" />
</div>

- **유사사례 검색 기능 구현:**
  - OpenSearch의 **KNN 벡터 검색**과 **BM25 키워드 검색**을 결합한 **하이브리드 유사도 검색 방식** 적용
  - KNN 검색을 통해 불편사항 간 의미적 유사도를 계산하고, BM25 검색으로 입력 항목(부서, 유형 등)의 필드 매칭 여부를 반영
  - 두 검색 결과의 점수를 **KNN 70% / BM25 30% 비율로 가중 합산**하여 최종 유사도 산정
  - BM25 점수는 검색 필드 개수에 따라 **균등 분배 방식**으로 계산하여 검색 품질을 안정적으로 유지


<br>
<img src="./images/자동 개선 요청문 생성.png" style="width: 70%" />

- **자동 개선 요청문 생성:**
  - 사용 중인 LLM의 파라미터(temperature, maxTokens, 모델 ARN 등)를 **별도 DB 테이블에서 관리**
  - 운영 환경에 따라 **모델 설정을 유연하게 변경할 수 있도록** 설계
  - 계열사별 프롬프트 템플릿을 개별적으로 관리하여 서비스 특성에 맞는 개선문 생성 지원
  - 프롬프트 최적화를 통해 **Claude 3 Haiku 모델**만으로도 충분한 품질의 결과를 확보


<br>
<img src="./images/입력 항목 자동 추천.png" style="width: 70%" />

- **입력 항목 자동 추천:**
  - 항목별 코드 목록과 선택 가이드를 LLM에 전달하여 **모델이 항목 단위로 정밀하게 값을 추론**하도록 개선
  - 계열사별 항목 구성이 상이하므로 **항목별·계열사별 프롬프트 개별 관리 구조**를 도입
  - 경량화된 프롬프트를 **Claude 3 Haiku 모델**로 병렬 호출하여 처리 속도를 약 **20초 → 12초**로 단축
  - 모델 사용 비용을 대폭 절감하고 효율적 운영 구조 확보

<br>

## 1.5. 문제 해결 및 인사이트

### **문제 ① — 정형 코드 데이터(RAG 적용 시 정확도 저하)**
입력 항목 자동 추천 기능의 초기 버전은 **Amazon Bedrock Knowledge Bases 기반 RAG 구조**로 설계되었으나, 운영 과정에서 **정형화된 코드 데이터(Key-Value 구조)**를 임베딩하는 방식에 근본적인 한계가 있었다.

Knowledge Bases는 데이터를 **라인 단위로 벡터화**하기 때문에
- 코드 ID ↔ 코드명 간의 연결 관계가 유지되지 않고
- 단순 키워드 중심 데이터는 **언어적 문맥이 부족**하여

임베딩 기반 의미 검색만으로는 정확한 매칭이 어려웠다.

### **해결 ① — Knowledge Bases → 항목별 LLM 직접 호출 구조로 전환**
정형 데이터의 특성과 RAG 구조의 한계를 분석한 뒤, 검색 로직을 근본적으로 변경하여 **항목별로 LLM을 직접 호출하는 방식**으로 구조를 개편하였다.

각 항목에 대해
- 코드 목록
- 선택 가이드
- 계열사별 항목 구성
을 함께 모델에 전달함으로써, LLM이 실제 업무 문맥 속에서 **항목 간 관계를 직접 고려하며 코드값을 추론**할 수 있도록 개선했다.

### **해결 ② — 동적 프롬프트 관리 체계 구축**
항목 및 계열사별 요구사항 차이를 반영하기 위해
- **코드 검증 로직**
- **다국어 처리**
- **계열사별 항목 구성 차이**

를 모두 고려한 **동적 프롬프트 관리 구조**를 설계했다. 이를 통해 유지보수성과 응답 정확도를 동시에 확보했다.

### **실무 인사이트**
이번 경험을 통해 다음과 같은 결론을 명확하게 얻었다:

1. **정형 데이터(Key-Value)는 임베딩 기반 RAG와 결합 시 구조적 한계가 존재한다.**
2. 데이터 성격에 따라
   - 벡터 검색
   - 키워드 기반 검색
   - LLM 직접 호출
   등을 **구분 적용해야 한다.**
3. AI 기능의 성공은 모델 선택보다 **데이터 구조 분석과 아키텍처 설계 결정**이 더 중요하다.

정형 데이터와 언어 모델의 결합 방식에 대해 실제 운영 환경 기준으로 명확한 전략을 수립할 수 있는 실무적 인사이트를 확보한 사례였다.


<br>

## 1.6. 결과 및 회고
**유사사례 검색 기능**을 통해 불편사항의 중복 등록을 방지하고 담당자가 이전 사례를 참고하여 개선안을 빠르게 도출할 수 있게 되었다. **입력자동화 기능**은 입력 프로세스의 복잡성을 완화하고 검증 부담을 줄여 전체 처리 효율을 향상시키는 데 기여했다.

이 프로젝트를 통해 **AI 모델의 성공적인 도입은 단순한 기술 적용이 아니라 데이터 구조와 실제 서비스 맥락에 맞춘 설계·조정 과정에 달려 있다**는 점을 명확하게 인식하게 되었다.


<br><br>

# 2. 대시보드 RAG 기반 AI 챗봇 개발 (2025.03)
## 2.1. 개요
- **프로젝트 유형:** 멤버십 관리자 대시보드용 **RAG AI 챗봇** 개발
- **참여 인원:** 3명
  - 백엔드 1명
  - 프론트엔드 1명
  - 퍼블리싱 1명
- **담당 역할:**
  - **챗봇 백엔드 전체 설계 및 AI 응답 처리 로직 구현**
  - **AWS Bedrock 기반 자연어 질의 응답 API 개발**
  - OpenAPI 3.0 명세 기반 **Knowledge Base 구성 및 벡터 인덱싱 구조 설계**
  - Redis 기반 **세션·문맥 유지 로직 개발** 및 대화 흐름 안정화 처리
- **기술 스택:**
  - **인프라:** AWS(**OpenSearch**, **Bedrock**, S3), Redis
  - **백엔드:** FastAPI, Python, AWS SDK
  - **프론트엔드:** Nextjs, TypeScript 

<br>

## 2.2. 프로젝트 설명
본 프로젝트는 멤버십 관리자 대시보드 내 데이터를 보다 쉽게 활용하기 위한 **AI 기반 대시보드 분석 챗봇**을 개발한 사례이다. 대시보드에는 다양한 통계·그래프·표 형태의 데이터가 제공되지만 사용자가 직접 해석해야 하는 비효율성이 존재했고, 이를 자연어 기반 인터페이스로 개선하는 것이 목표였다.

### ① 자연어 기반 대시보드 분석
- 사용자가 자연어로 질문하면 챗봇이 **대시보드 데이터를 기반으로** 의미 있는 분석 결과를 제공하도록 설계하였다.
- 챗봇은 OpenAPI 명세를 기반으로 각 데이터의 의미와 응답 형식을 이해하고 사용자의 질문을 분석해 **적절한 API 요청을 구성하고 결과를 해석하여 응답하는 구조**로 구현되었다.

### ② API 명세 기반 RAG 구조
- 대시보드 API 명세는 OpenAPI 3.0 형식으로 작성되어 S3에 저장되며 **Amazon OpenSearch 에 벡터화되어 관리**된다.
- FastAPI 서버는 Bedrock과 통신하며 OpenSearch에 저장된 API 명세를 기반으로 **사용자의 질문을 처리하고 해당 API 구조에 맞는 응답을 생성**한다.

### ③ 세션 기반 문맥 유지
- 사용자의 최초 질의 시 챗봇은 대시보드 API 응답 데이터를 함께 전달받아 **Redis에 세션 단위로 저장**한다. 
- 이후 동일 세션에서는 이전 질의·응답 문맥을 활용해 보다 **일관성 있는 대화 흐름을 제공**하며 세션 정보는 Redis에서 **60분간 유지 후 자동 삭제**되도록 구성하였다.

<br>

## 2.3. 담당 업무
- **API 아키텍처 설계 및 구현:**
  - FastAPI 기반으로 챗봇 API 서버 설계 및 엔드포인트 구현
  - API 호출, 세션 관리, 문맥 유지, 사용자 입력 처리 구조 개발
- **Knowledge Base 구축:**
  - OpenAPI 3.0 형식으로 작성된 API 명세를 준비
  - Amazon S3 업로드 → OpenSearch 벡터화 저장
- **AI 응답 처리 로직 설계:**
  - AWS Bedrock의 Claude 모델을 이용하여
    사용자의 질문과 API 명세 간의 연관성을 분석하고 응답 생성
  - Redis를 활용해 세션별 질의·응답 히스토리 관리 및 문맥 유지
- **성능 및 운영 개선:**
  - AI 챗봇 호출 횟수를 제한함으로써 과도한 비용이 발생하지 않도록 처리
  - Redis TTL(Time To Live) 설정을 통해 불필요한 세션 메모리 관리

<br>

## 2.4. 기술적 특징
![Image](./images/423763399-af70afd1-4aa8-4880-b5e3-7a4e7722c935.jpg)

- **Bedrock + OpenSearch 기반의 RAG 구조 구현:**
  OpenAPI 명세를 벡터화하여 Amazon OpenSearch에 저장하고,
  Bedrock LLM이 이를 참조해 응답을 생성하는 Retrieval-Augmented Generation 구조를 구축
- **세션 기반 문맥 관리:**
  Redis를 사용하여 각 세션 ID별로 질의·응답 이력을 저장하고
  사용자의 대화 흐름을 유지함으로써 문맥 인식이 가능한 챗봇 구현
- **모듈형 FastAPI 구조:**
  챗봇, 세션, 검색, 응답 생성을 독립 모듈로 구성해
  유지보수성과 확장성을 높임

<br>

## 2.5. 문제 해결 및 인사이트

### **문제 ① — 세션 문맥 유지 불안정**
Redis TTL이 너무 짧게 설정되어 세션이 예상보다 빠르게 만료되면서 대화 문맥이 끊기는 문제가 있었다. 사용자가 이전 질문의 연속으로 질의하더라도 모델이 이를 새로운 대화로 인식해 문맥 기반 응답이 이루어지지 않는 상황이 반복적으로 발생했다.

### **해결 ① — TTL 확장 및 세션 키 규칙 정비**
세션 유지 전략을 재검토하여 TTL을 **60분으로 확장**하고, 세션별 키 생성 규칙을 **일관된 패턴으로 통합**했다. 이를 통해 문맥 유지가 안정적으로 이루어지며, 대화 흐름이 끊기는 현상이 크게 감소하였다.

<br>

### **문제 ② — 챗봇의 목적 외 질문 처리 문제**
대시보드 분석을 위한 챗봇임에도 불구하고, 사용자가 일반 대화를 입력하면 모델이 이를 그대로 처리하면서 불필요하거나 서비스 목적과 맞지 않는 응답을 생성하는 문제가 있었다. 이는 LLM이 대화 범위를 제한할 명확한 기준이 제공되지 않아서 발생한 현상이었다.

### **해결 ② — 목적 기반 응답 제약 프롬프트 적용**
프롬프트 구성에 “대시보드 데이터 분석과 관련된 질문에만 응답한다”는 **명확한 제약 조건**을 추가해 모델의 응답 범위를 제한했다. 이로써 일반 대화나 서비스 목적과 무관한 요청에 대해 불필요한 응답이 생성되는 문제를 효과적으로 방지할 수 있었다.

<br>

### **실무 인사이트**
이 경험을 통해 다음과 같은 점을 명확히 확인할 수 있었다:

1. **LLM 기반 대화형 시스템에서 안정적인 문맥 유지는 모델 성능만큼이나 중요하다.**
2. 세션 TTL 관리와 키 규칙 정비처럼 **세션 관리 전략이 대화 품질의 핵심 요소**가 된다.
3. 챗봇의 목적을 벗어난 응답을 방지하려면 **프롬프트 단계에서 대화 범위를 명확하게 제한하는 설계가 필수적**이다.

LLM 기반 API 어시스턴트 구조의 품질은 고도화된 모델 자체보다 세션 관리·프롬프트 설계·대화 범위 제어 같은 **구조적 안정성**에서 결정된다는 점을 실무적으로 체감한 사례였다.


<br>

## 2.6. 결과 및 회고
본 프로젝트를 통해 대시보드 내 데이터를 자연어로 조회·분석할 수 있는 인터페이스를 구축하였다. 챗봇은 실제 운영 환경에서 사용자의 질문에 평균 3초 이내로 응답하였으며 더 좋은 품질의 응답을 위해 프롬프트 조정과 모델 변경을 지속적으로 수행하였다.

이 경험을 통해 **AI 챗봇은 단순 질의응답을 넘어 시스템 내 데이터를 이해하고 해석하는 도구로 발전할 수 있음**을 실감하였다. 또한 LLM 기반 구조에서는 **지식베이스 설계와 세션 관리 전략이 전체 응답 품질을 좌우하는 핵심 요소**임을 명확히 인식하게 되었다.


<br><br>

# 3. 서비스 마이그레이션 자동화 및 안정화 (2024.02 ~ 2024.03)
## 3.1. 개요
- **프로젝트 유형:** 멀티 테넌트 SaaS 서비스의 **아키텍처 전환 및 데이터 마이그레이션 자동화**
- **참여 인원:** 4명 (
  - 백엔드 및 인프라 2명
  - QA 2명
- **담당 역할:**
  - **대규모 MySQL 간 데이터 마이그레이션 설계 및 자동화 스크립트 개발**
  - 스키마 구조가 서로 다른 MySQL 5.7 ↔ 8.0 환경 간의 수천만 건 데이터 이전 작업 수행
  - 서비스 중단 최소화를 위한 **병렬 처리 기반 마이그레이션 로직** 개발
  - 트리거·이벤트 백업·복원, 스키마 차이 자동 분석, 검증 리포트 생성 프로세스 구축
- **기술 스택:**
  - **DB:** MySQL 5.7 / 8.0
  - **인프라:** Docker, AWS Route53, Nginx, crontab
  - **언어 및 도구:** Node.js, Shell Script, Excel 자동 리포트

<br>

## 3.2. 프로젝트 설명
본 프로젝트는 기존의 **컬럼 베이스 멀티테넌트 구조**를 **도커 기반 테넌트별 스키마 분리 구조**로 전환하는 과정에서 수행된 대규모 데이터 마이그레이션 작업이다. 구조 전환 과정에서 발생하는 데이터 불일치와 트리거 의존성 문제를 해결하며 수천만 건의 데이터를 무중단으로 안정적으로 이전하는 것이 핵심 목표였다.

### ① 멀티테넌트 구조 전환
- 기존 시스템은 단일 테이블 내 컬럼으로 테넌트를 구분하는 구조였으나 신규 환경에서는 **테넌트별 독립 컨테이너와 개별 스키마를 사용하는 구조로 전환**되었다.
- 이에 따라 불필요한 테이블을 제거하고 테이블 수를 약 **379개에서 218개로 통합**해야 했으며 **서비스 중단 없이** 데이터를 안전하게 이전해야 했다.

### ② 대규모 데이터 마이그레이션
- **수천만 건의 데이터**를 신규 스키마 구조에 맞춰 변환하는 과정에서 **테이블 스키마 불일치**, 트리거 의존성, **대량 INSERT 시 메모리 부족**, Prepared Statement 예외 등 여러 문제가 있었다.
- 이를 해결하기 위해 전체 이전 과정은 **자동화 스크립트 기반으로 설계**되었으며 스키마 분석, 트리거 관리, Batch 처리 등 모든 과정이 자동화되도록 구성했다.

### ③ 안정적 이전을 위한 자동화 및 검증
- 마이그레이션 과정 전반을 자동화하여 **스키마 차이 분석**, **트리거 DROP 및 복원**, **데이터 이전**, **검증 리포트 생성**까지 모두 일관된 흐름으로 수행할 수 있도록 구성하였다.
- 이를 통해 신규 구조로의 전환 과정에서도 **데이터 무결성을 유지하고 서비스 중단을 최소화**할 수 있었다.


<br>

## 3.3. 담당 업무
- **DB 구조 차이 분석 자동화:**
  - 두 데이터베이스 간 스키마·컬럼·제약 조건 차이를 자동 분석하여 Excel 리포트로 출력
  - 스키마 변경에 따른 대응 방안(추가/삭제/타입 불일치)을 분류
- **데이터 이전 자동화:**
  - 트리거·이벤트를 삭제 후 재생성하는 절차 자동화
  - Prepared Statement 예외 방지를 위해 **Row 단위 500건 Batch 처리**
- **성능 최적화 및 안정화:**
  - 대용량 테이블 마이그레이션 시 멀티프로세스 기반 병렬 처리로 속도 향상
  - 잘못된 인덱스 선택으로 인한 성능 저하 문제를 인덱스 재구성으로 해결
- **인프라 환경 전환:**
  - AWS Route53 도메인 라우팅 및 SSL 인증서 재적용
  - Nginx 리다이렉트 검증 시 Body 데이터 누락 문제를 proxy_pass 설정으로 수정

<br>

## 3.4. 기술적 특징
- MySQL **컬럼 베이스 → 스키마 베이스 구조 전환** 자동화 스크립트 구현
- **트리거 DROP → 데이터 이전 → 복구 자동화**를 통해 무결성 유지
- 대규모 데이터 이관 시 **멀티프로세스 기반 병렬 처리 및 메모리 제어** 적용
- 자동화 결과를 Excel 리포트로 변환하여 팀 단위 검증 효율성 향상
- Node.js 기반 커넥션 풀 구성으로 안정적인 장시간 마이그레이션 수행

<br>

## 3.5. 문제 해결 및 인사이트

### **문제 ① — MySQL 트리거 일괄 비활성화 불가**
MySQL은 전체 트리거를 한 번에 비활성화하는 기능을 제공하지 않기 때문에 대량 데이터 이전 과정에서 트리거가 계속 실행되어 무결성 검사와 연관 로직이 불필요하게 작동하는 문제가 있었다.

### **해결 ① — 트리거 생성문 백업 후 DROP → 복원 절차 구축**
모든 트리거의 생성문을 텍스트 파일로 추출해 백업한 뒤 일괄 DROP하고, 데이터 이전이 끝난 후 다시 복원하는 방식을 적용하였다. 이 구조를 자동화하여 마이그레이션 과정 전체에서 안정적으로 트리거를 통제할 수 있었다.

<br>

### **문제 ② — Prepared Statement 예외 및 메모리 부족**
수천만 건 단위로 데이터를 이전하는 과정에서 Prepared Statement 누적 및 메모리 부족 문제가 발생해 대량 INSERT 작업이 중단되거나 처리 속도가 급격히 느려지는 상황이 반복되었다.

### **해결 ② — Batch 분할 및 메모리 확장**
쿼리 Batch 크기를 **500건 단위로 분할**해 메모리 점유를 안정적으로 유지하도록 조정했으며 Node.js 런타임 메모리도 확장하여 장시간 마이그레이션 환경에서도 프로세스가 중단되지 않도록 개선했다.

<br>

### **문제 ③ — Nginx 리다이렉트 시 Body 데이터 손실**
마이그레이션 후 트래픽 전환 과정에서 특정 엔드포인트의 POST 요청이 정상적으로 전달되지 않는 문제가 발생했다. Nginx의 return 문을 이용한 리다이렉트 방식은 Body 데이터를 그대로 전달하지 못하는 구조적 한계를 갖고 있었다.

### **해결 ③ — proxy_pass 기반 라우팅으로 전환**
리다이렉트 방식을 return에서 **proxy_pass**로 전환하여 요청 Body를 그대로 유지한 채 목적지 서버로 전달할 수 있도록 수정했다. 이를 통해 서비스 전환 과정에서 요청 데이터 손실 문제를 완전히 해소했다.

<br>

### **실무 인사이트**
이번 일련의 문제 해결 과정을 통해 서비스 아키텍처 전환 과정에서는 데이터 무결성 보장, Memory/Statement 안정성 확보, 라우팅 단계의 미세한 동작 차이까지 모두 고려해야 한다는 점을 명확히 확인했다. 이를 기반으로 **데이터 손실 없이 장시간 중단 없는 안정적 전환이 가능함을 실무적으로 입증한 사례**가 되었다.

<br>

## 3.6. 결과 및 회고
야간에 진행된 마이그레이션은 약 **3시간 내에 완료**되었으며, 데이터 무결성과 서비스 연속성을 모두 확보하였다. 마이그레이션 이후 라우팅 재설정, 인증서 적용, 통합 테스트까지 무중단으로 마무리되었고 **다음날 정상 운영이 가능했다**.

본 경험을 통해 복잡한 구조 변경도 철저한 분석·자동화·테스트를 기반으로 하면 안정적으로 수행할 수 있음을 확인하였다. 또한 마이그레이션 절차를 표준화하고 문서화하여 이후 진행된 고객사의 **MySQL 5.7 → 8.0 업그레이드 프로젝트**에서도 QA 및 기획 프로세스를 주도하며 안정적인 이관을 성공적으로 수행할 수 있었다.


<br><br>